#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Query our malware hashes in Virus Total to get some additional information.
"""

__maintainer__ = "Raphael Hiesgen"
__email__ = "raphael.hiesgen@haw-hamburg.de"
__copyright__ = "Copyright 2018-2021"

import json
import os
import pause
import requests

from datetime import date, datetime, timedelta, timezone
from enum import Enum
from json import JSONEncoder
from pathlib import Path

max_requests_per_minute = 4
max_requests_per_day = 500
max_requests_per_month = 15000

one_minute = timedelta(minutes=1)
one_day = timedelta(days=1)

state_file_name = ".cse2.vtchecker.json"
# state_file_path = os.path.join(Path.home(), state_file_name)

# -- urls ---------------------------------------------------------------------

base_url = "https://www.virustotal.com/api/v3/{}"
search_url = base_url.format("search")


# -- time coding --------------------------------------------------------------

# Subclass JSONEncoder to serialze datatime as an iso-formatted string.
class DateTimeEncoder(JSONEncoder):
    # Override the default method
    def default(self, obj):
        if isinstance(obj, (date, datetime)):
            return obj.isoformat()


# -- Errors -------------------------------------------------------------------


class VTError(Exception):
    """Base class for VT errors"""

    pass


class APIError(VTError):
    """Raised when the request fails"""

    pass


class RateLimitReached(VTError):
    """Raised when the input value is too large"""

    pass


class RequestsError(VTError):
    """Raised when requests throws"""

    pass


# -- Virus Total use ----------------------------------------------------------

expected_failures = [400, 401, 403, 404, 409, 424, 429, 503, 504]


def handle_error(status_code, res):
    def print_code_msg():
        obj = res.json()
        code = obj["error"]["code"]
        msg = obj["error"]["message"]
        print(f"request failed ({status_code}): code = {code}, message = {msg}")

    if status_code in expected_failures:
        print_code_msg()
    else:
        print(f"unexpected status code: {status_code}")


def utc_now():
    return datetime.now().astimezone(timezone.utc)


class VirusTotal:
    def __init__(self, apikey, proxies=None, apiversion="v3"):
        self.apikey = apikey
        self.proxies = proxies

        self.last_query = None
        self.day = None
        self.month = None

        self.requested_this_minute = 0
        self.requested_this_day = 0
        self.requested_this_month = 0

        assert apiversion == "v3", "only API v3 is supported"

    def update_time(self, now):
        diff = now - self.last_query
        # Check minute.
        if diff > one_minute:
            self.last_query = now
            self.requested_this_minute = 0
            # Check day.
            day = now.strftime("%Y%m%d")
            if day > self.day:
                self.day = day
                self.requested_this_day = 0
                month = now.strftime("%Y%m")
                # Check month.
                if month > self.month:
                    self.month = month
                    self.requested_this_month = 0

    def search(self, hash, timeout=None, blocking=False):
        # print(f"query for '{hash}'")
        # From VirtusTotal API documentation:
        # curl --request GET \
        #   --url 'https://www.virustotal.com/api/v3/search?query=<query>' \
        #   --header 'x-apikey: self.apikey'

        # Update time, potentially reset counts.
        now = utc_now()
        if self.last_query is None:
            self.last_query = now
            self.day = now.strftime("%Y%m%d")
            self.month = now.strftime("%Y%m")
        self.update_time(now)

        # Check quota.
        if self.requested_this_minute >= max_requests_per_minute:
            print(f"out of requests this minute")
            if blocking:
                target = self.last_query + one_minute
                print(f"waiting until '{target}'")
                pause.until(target)
                return self.search(hash, timeout, blocking)
            else:
                raise RateLimitReached("no more tokens this minute")
        elif self.requested_this_day >= max_requests_per_day:
            print(f"out of requests this day")
            if blocking:
                target = now + one_day
                target.replace(hour=0, minute=0, second=0, microsecond=0)
                datestr = target.strftime("%Y-%m-%d")
                parts = datestr.split("-")
                target = datetime(year=parts[0], month=parts[1], day=parts[2])
                print(f"waiting until '{target}'")
                pause.until(target)
                return self.search(hash, timeout, blocking)
            else:
                raise RateLimitReached("no more tokens this day")
        elif self.requested_this_month >= max_requests_per_month:
            print(f"out of requests this month")
            if blocking:
                target = now
                target.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
                datestr = target.strftime("%Y-%m-01")  # Set day to the first.
                parts = datestr.split("-")
                year = int(parts[0])
                month = int(parts[1])
                if month == 12:
                    year += 1
                    month = 1
                else:
                    month += 1
                target = datetime(year=year, month=month, day=1)
                print(f"waiting until '{target}'")
                pause.until(target)
                return self.search(hash, timeout, blocking)
            else:
                raise RateLimitReached("no more tokens this month")

        def update_quota():
            self.requested_this_minute += 1
            self.requested_this_day += 1
            self.requested_this_month += 1

        # Required data.
        params = {"query": hash}
        # Make request.
        try:
            req = requests.get(
                search_url,
                params=params,
                headers={"x-apikey": self.apikey},
                proxies=self.proxies,
                timeout=timeout,
            )
            update_quota()
        except requests.exceptions.ConnectTimeout as err:
            raise RequestsError(f"Connect Timeout: {err}")
        except requests.exceptions.ConnectionError as err:
            raise RequestsError(f"Connection Error: {err}")
        except requests.exceptions.Timeout as err:
            raise RequestsError(f"[ERR] Timeout: {err}")
        except requests.exceptions.RequestException as err:
            raise RequestsError(f"[ERR] Request Exception: {err}")
        if req:  # req.status_code == requests.codes.ok:
            # print("query successful")
            # print(req.text)
            return json.loads(req.text)
        else:
            handle_error(req.status_code, req)
            raise APIError(f"request failed: {req.status_code}")

    def load_stats(self, online=False):
        fetch_online_failed = False
        if online:
            # From VirtusTotal API documentation:
            # curl --request GET \
            #   --url https://www.virustotal.com/api/v3/users/{id} \
            #   --header 'x-apikey: <your API key>'
            # print("[ERR]Â online is not implemented yet!")
            # return
            # Make request.
            try:
                print("will try to query VT for open tokens")
                req = requests.get(
                    base_url.format(f"users/{self.apikey}"),
                    headers={"x-apikey": self.apikey},
                    proxies=self.proxies,
                )
                if req.status_code == requests.codes.ok:
                    # print(req.text)
                    obj = json.loads(req.text)
                    quotas = obj["data"]["attributes"]["quotas"]
                    # print(json.dumps(quotas, indent=2))
                    self.requested_this_day = quotas["api_requests_daily"]["used"]
                    self.requested_this_month = quotas["api_requests_monthly"]["used"]
                    limit_day = quotas["api_requests_daily"]["allowed"]
                    limit_month = quotas["api_requests_monthly"]["allowed"]
                    print(f"got quota from server")
                    print(f"day  : {self.requested_this_day:>4}/{limit_day:>10}")
                    print(f"month: {self.requested_this_month:>4}/{limit_month:>10}")
                else:
                    print(f"request for user info failed: {req.status_code}")
                    handle_error(req.status_code, req)
                    fetch_online_failed = True
            except requests.exceptions.ConnectTimeout as err:
                print(f"Connect Timeout: {err}")
                fetch_online_failed = True
            except requests.exceptions.ConnectionError as err:
                print(f"Connection Error: {err}")
                fetch_online_failed = True
            except requests.exceptions.Timeout as err:
                print(f"[ERR] Timeout: {err}")
                fetch_online_failed = True
            except requests.exceptions.RequestException as err:
                print(f"[ERR] Request Exception: {err}")
                fetch_online_failed = True
                # print(f"failed to query user information, will try locally")
        if not online or fetch_online_failed:
            if Path(state_file_name).is_file():
                print(f"reading vt state")
                with open(state_file_name, "rt", encoding="UTF-8") as fh:
                    data = fh.read()
                    obj = json.loads(data)
                    datetimestr = obj["time"]["last_query"]
                    self.last_query = datetime.fromisoformat(datetimestr)
                    self.day = obj["time"]["day"]
                    self.month = obj["time"]["month"]
                    self.requested_this_minute = obj["requested"]["minute"]
                    self.requested_this_day = obj["requested"]["day"]
                    self.requested_this_month = obj["requested"]["month"]
            else:
                print("no local stats file found")

    def save_stats(self):
        if self.last_query is None:
            print(f"haven't performed requests yet, nothing to write")
            return
        print(f"writing vt state")
        obj = {
            "requested": {
                "minute": self.requested_this_minute,
                "day": self.requested_this_day,
                "month": self.requested_this_month,
            },
            "time": {
                "last_query": self.last_query,
                "day": self.day,
                "month": self.month,
            },
        }
        with open(state_file_name, "wt", encoding="UTF-8") as fh:
            json.dump(obj, fh, cls=DateTimeEncoder)

    def remaining_this_day(self):
        return max_requests_per_day - self.requested_this_day

    def can_go_at_full_speed(self):
        # Full speed is 4 requests per minute. Since we only have 500 probes
        # per day we shouldn't waste our tokens too early. But if we realize
        # that have just enough tokens to probe "at full speed" we can use
        # those to re-check old info.

        # Calculate remaining minutes.
        now = utc_now()
        target = now + one_day
        target = target.replace(hour=0, minute=0, second=0, microsecond=0)
        delta = target - now
        seconds = int(delta.total_seconds())
        possible_requests = int(seconds / 4)
        print(f"day has {seconds}s remaing ({possible_requests} requests)")
        print(f"and we have {self.remaining_this_day()} tokens left")
        threshold = int(self.remaining_this_day() * 1.2)
        print(f"rounding to {threshold}")
        # print(f"so: {possible_requests <= self.remaining_this_day()}")
        return possible_requests <= threshold
