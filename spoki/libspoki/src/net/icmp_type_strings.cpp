// clang-format off
// DO NOT EDIT: this file is auto-generated by generate-enum-strings.
// Run the target update-enum-strings if this file is out of sync.
#include "spoki/config.hpp"
#include "caf/string_view.hpp"

SPOKI_PUSH_DEPRECATED_WARNING

#include "spoki/net/icmp_type.hpp"

#include <string>

namespace spoki::net {

std::string to_string(icmp_type x) {
  switch(x) {
    default:
      return "???";
    case icmp_type::echo_reply:
      return "spoki::net::icmp_type::echo_reply";
    case icmp_type::dest_unreachable:
      return "spoki::net::icmp_type::dest_unreachable";
    case icmp_type::source_quench:
      return "spoki::net::icmp_type::source_quench";
    case icmp_type::redirect_message:
      return "spoki::net::icmp_type::redirect_message";
    case icmp_type::echo_request:
      return "spoki::net::icmp_type::echo_request";
    case icmp_type::router_advertisement:
      return "spoki::net::icmp_type::router_advertisement";
    case icmp_type::router_solicitation:
      return "spoki::net::icmp_type::router_solicitation";
    case icmp_type::time_exceeded:
      return "spoki::net::icmp_type::time_exceeded";
    case icmp_type::bad_ip_header:
      return "spoki::net::icmp_type::bad_ip_header";
    case icmp_type::timestamp:
      return "spoki::net::icmp_type::timestamp";
    case icmp_type::timestamp_reply:
      return "spoki::net::icmp_type::timestamp_reply";
    case icmp_type::information_request:
      return "spoki::net::icmp_type::information_request";
    case icmp_type::information_reply:
      return "spoki::net::icmp_type::information_reply";
    case icmp_type::addr_mark_request:
      return "spoki::net::icmp_type::addr_mark_request";
    case icmp_type::addr_mark_reply:
      return "spoki::net::icmp_type::addr_mark_reply";
    case icmp_type::extended_echo_request:
      return "spoki::net::icmp_type::extended_echo_request";
    case icmp_type::extended_echo_reply:
      return "spoki::net::icmp_type::extended_echo_reply";
    case icmp_type::other:
      return "spoki::net::icmp_type::other";
  };
}

bool from_string(caf::string_view in, icmp_type& out) {
  if (in == "spoki::net::icmp_type::echo_reply") {
    out = icmp_type::echo_reply;
    return true;
  } else if (in == "spoki::net::icmp_type::dest_unreachable") {
    out = icmp_type::dest_unreachable;
    return true;
  } else if (in == "spoki::net::icmp_type::source_quench") {
    out = icmp_type::source_quench;
    return true;
  } else if (in == "spoki::net::icmp_type::redirect_message") {
    out = icmp_type::redirect_message;
    return true;
  } else if (in == "spoki::net::icmp_type::echo_request") {
    out = icmp_type::echo_request;
    return true;
  } else if (in == "spoki::net::icmp_type::router_advertisement") {
    out = icmp_type::router_advertisement;
    return true;
  } else if (in == "spoki::net::icmp_type::router_solicitation") {
    out = icmp_type::router_solicitation;
    return true;
  } else if (in == "spoki::net::icmp_type::time_exceeded") {
    out = icmp_type::time_exceeded;
    return true;
  } else if (in == "spoki::net::icmp_type::bad_ip_header") {
    out = icmp_type::bad_ip_header;
    return true;
  } else if (in == "spoki::net::icmp_type::timestamp") {
    out = icmp_type::timestamp;
    return true;
  } else if (in == "spoki::net::icmp_type::timestamp_reply") {
    out = icmp_type::timestamp_reply;
    return true;
  } else if (in == "spoki::net::icmp_type::information_request") {
    out = icmp_type::information_request;
    return true;
  } else if (in == "spoki::net::icmp_type::information_reply") {
    out = icmp_type::information_reply;
    return true;
  } else if (in == "spoki::net::icmp_type::addr_mark_request") {
    out = icmp_type::addr_mark_request;
    return true;
  } else if (in == "spoki::net::icmp_type::addr_mark_reply") {
    out = icmp_type::addr_mark_reply;
    return true;
  } else if (in == "spoki::net::icmp_type::extended_echo_request") {
    out = icmp_type::extended_echo_request;
    return true;
  } else if (in == "spoki::net::icmp_type::extended_echo_reply") {
    out = icmp_type::extended_echo_reply;
    return true;
  } else if (in == "spoki::net::icmp_type::other") {
    out = icmp_type::other;
    return true;
  } else {
    return false;
  }
}

bool from_integer(std::underlying_type_t<icmp_type> in,
                  icmp_type& out) {
  auto result = static_cast<icmp_type>(in);
  switch(result) {
    default:
      return false;
    case icmp_type::echo_reply:
    case icmp_type::dest_unreachable:
    case icmp_type::source_quench:
    case icmp_type::redirect_message:
    case icmp_type::echo_request:
    case icmp_type::router_advertisement:
    case icmp_type::router_solicitation:
    case icmp_type::time_exceeded:
    case icmp_type::bad_ip_header:
    case icmp_type::timestamp:
    case icmp_type::timestamp_reply:
    case icmp_type::information_request:
    case icmp_type::information_reply:
    case icmp_type::addr_mark_request:
    case icmp_type::addr_mark_reply:
    case icmp_type::extended_echo_request:
    case icmp_type::extended_echo_reply:
    case icmp_type::other:
      out = result;
      return true;
  };
}

} // namespace spoki::net

SPOKI_POP_WARNINGS
